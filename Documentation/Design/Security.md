#explanation

# Overview

Whilst we currently produce the hardware which is deployed in the field, this cannot be seen as any type of security boundary and it may not be the case in the future that the hardware can even be considered 'ours'. Because of this, we must tread the device and any code running upon it as untrusted and possibly hostile in the same way that we treat the JavaScript running in the web browser as such.

The design of the system is to enforce these main facts:
1. Only devices we have sold to our customers can interact with our cloud services.
2. Our software deployed to devices only communicates with our trusted cloud services.
3. A device becoming compromised cannot move laterally affecting data from other devices or for other customers. This includes denial-of-service.

# Device Authentication

One guarantee we have is that every Hub device will come from a production line managed by us. This means we can register the devices into our system at birth knowing they have unique credentials which haven't been tampered with.

Devices have two factors that they authenticate with: machine ID and machine secret.

# JWT Authorization

[JSON Web Tokens](https://en.wikipedia.org/wiki/JSON_Web_Token) offer unique possibilities over other key alternatives. No only do they offer signing of the token, but can contain arbitrary JSON data which the signer can use to add metadata to the token. Another advantage is it does not rely on a central store of tokens to verify their validity. A service (for example a distributed service) only requires the secret key to verify the signature and thus the contents of a token.

## Token Generation

Tokens are generated by a custom API running as a Supabase Edge Function. The same secret key that is used for supabase is used to sign the device tokens making it possible for devices to call Supabase API's. The only difference between a token created by Supabase and one created by the device API is the role will be `device`.

# Transport Encryption

All communication between devices and cloud are over HTTPS which provides protection against MITM attacks.

Note that we do not yet implement [certificate pinning](https://en.wikipedia.org/wiki/HTTP_Public_Key_Pinning), mainly because this is not yet possible with [Rustls](https://crates.io/crates/rustls).

# Package Signing

Because we distribute our binaries as Debian packages, we can lean on their well established system for validating packages.
